# ООП.

## Задача 1

В сказке А. С. Пушкина "Сказка о царе Салтане" упоминается невиданное чудо: остров, на котором живёт белка, которая грызёт орехи из чистого золота с изумрудными ядрами. Ниже приведён этот отрывок:

```
«Мы объехали весь свет;
За морем житье не худо;
В свете ж вот какое чудо:
Остров на море лежит,
Град на острове стоит
С златоглавыми церквами,
С теремами да садами;
Ель растет перед дворцом,
А под ней хрустальный дом;
Белка там живет ручная,
Да затейница какая!
Белка песенки поет,
Да орешки всё грызет,
А орешки не простые,
Всё скорлупки золотые,
Ядра — чистый изумруд;
Слуги белку стерегут,
Служат ей прислугой разной —
И приставлен дьяк приказный
Строгий счет орехам весть;
Отдает ей войско честь;
Из скорлупок льют монету,
Да пускают в ход по свету;
Девки сыплют изумруд
В кладовые, да под спуд;
Все в том острове богаты,
Изоб нет, везде палаты;
А сидит в нем князь Гвидон;
Он прислал тебе поклон».
```

Мы понимаем, что А. С. Пушкин описывает чрезвычайно хорошо налаженный процесс поднятия экономики княжества с помощью золотых монет и изумрудов.

**Напишите реализацию этого процесса.** В нём участвуют несколько ключевых объектов, взаимодействие с которыми ради обеспечения безопасности казны осуществляется **только** с помощью метода доступа **get**, либо **set**,  которые вам необходимо реализовать. Это позволит скрыть от чужих глаз то, что трогать не следует. Вот инициализации и описания ключевых объектов:


### Изумруд (`Emerald`)

```C#
public class Emerald
{
    private int _status; // статус изумруда: 0 - не учтён, 1 - учтён, 2 - отправлен под спуд
    private double _price; // цена изумруда

    public Emerald()
    {
        _status = 0;
        _price = 0.0;
    }

    public int Status
    {
        get { return _status; }
        set { _status = value; }
    }

    public double Price
    {
        get { return _price; }
        set { _price = value; }
    }
}
```

Что можно делать с изумрудом:

* получать информацию о статусе;
* изменять информацию о статусе:
    * числовое значение статуса изумруда не может стать меньше;
    * учитывать (`Account()`);
    * отправлять под спуд (`Store()`);
* оценивать изумруд;
* получать информацию о цене изумруда.



### Скорлупка (`Shell`)

```C#
public class Shell
{
    private int _status; // статус скорлупки: 0 - не учтена, 1 - учтена, 2 - отправлена в монетолитейное отделение, 3 - переплавлена в монету
    private double _price; // цена скорлупки

    public Shell()
    {
        _status = 0;
        _price = 0.0;
    }

    public int Status { get; set; }

    public double Price { get; set; }
}
```

Что можно делать со скорлупкой:

* получать информацию о статусе;
* изменять информацию о статусе:
    * числовое значение статуса скорлупки не может стать меньше.
    * учитывать (`Account()`);
    * отправлять в монетолитейное отделение (`Process()`);
    * переплавлять в монету (`Smelt()`);
        * в таком случае создаётся новый объект: монета `Coin()` -- для неё нужно создать запись в архиве;
* оценивать скорлупку;
* получать информацию о цене скорлупки.
* для изменения статуса можно предварительно реализовать **set**, а затем вызывать его в реализации вышеописанных функций.

### Монета (`Coin`)

```C#
public class Coin
{
    private string _serialNumber; // серийный номер монеты
    private int _year; // год выпуска монеты
    private double _value; // номинал монеты

    public Coin(string serialNumber, int year, double value)
    {
        _serialNumber = serialNumber;
        _year = year;
        _value = value;
    }

    public string SerialNumber { get; set; }

    public int Year { get; set; }

    public double Value { get; set; }
}
```

При создании монеты все её атрибуты инициализируются и потом нигде не изменяются. Что можно делать с монетой:

* получать информацию о серийном номере;
* получать информацию о годе выпуска;
* получать информацию о номинале монеты;

### Запись (`Entry`)

```с#
class Entry: 
public class Entry
{
    private int _ID; // идентификационный номер, создаётся автоматически
    private object _item; // указатель на объект
    private DateTime _date; // дата создания записи
    private string _info; // дополнительная информация об объекте
    private bool _secret; // информация засекречена?

    public Entry(object item, string date = "01.01.1970", string info = "", bool secret = false)
    {
        _ID = GetNextID();
        _item = item;
        _date = DateTime.Parse(date);
        _info = info;
        _secret = secret;
    }

    private int GetNextID()
    {
        // напишите реализацию этого метода
    }

    public int ID
    {
        get { return _ID; }
    }

    public object Item
    {
        get { return _item; }
    }

    public DateTime Date
    {
        get { return _date; }
    }

    public string Info
    {
        get { return _info; }
    }

    public bool Secret
    {
        get { return _secret; }
    }
}

```

Что можно делать с записью:

* получать информацию об ID объекта;
* получать информацию о записанном объекте;
* получать информацию о дате создания записи;
* получать дополнительную информацию об объекте;
* изменять дополнительную информацию об объекте;
* получать информацию о засекреченности записи;
* засекречивать или рассекречивать запись.

### Архив (`Archive`)

```C#
public class Archive
{
    private List<item> _storage = new List<item>(); // список учтённых объектов

    public Archive()
    {
    }

    public void AddItem(object item)
    {
        _storage.Add(item);
    }

    public List<object> GetStorage()
    {
        return _storage;
    }
}
```

Что можно делать с помощью архива:

* добавлять запись `Entry()` о новом изумруде/скорлупке/монете (`Add()`) в конец архива;
* получать информацию из записи об изумруде/скорлупке/монете из архива по индексу (`get()`);
    * здесь нужно реализовать **getter** для атрибутов как записи `Entry()` (получение типа сохранённого объекта, даты записи, дополнительной информации), так и атрибутов объектов (`Coin()`, `Shell()`, `Emerald()`);
    * при попытке получить информацию об удалённом или засекреченном объекте нужно возвращать `None`;
* изменять запись об изумруде/скорлупке/монете в архиве (`Edit()`) по индексу;
    * менять указатель на объект **нельзя**;
    * дату создания изменять **нельзя**;
    * дополнительную информацию изменять **можно**, здесь нужно реализовать **set**;
* засекречивать информацию о записи (`Classify()`) по индексу;
    * в таком случае получить информацию об этой записи нельзя;
* рассекречивать информацию о записи (`Declassify()`) по индексу;
    * в этом случае ограничения на получение информации снимаются;
* удалять запись об изумруде/скорлупке/монете (`Delete()`) по индексу;
    * в таком случае запись по индексу перезаписывается на `None`.

### Проверка

> #### Отображение информации (необязательное задание)
>
> Переопределить строковое отображение классов объектов `Coin()`, `Shell()`, `Emerald()` , используя метод `ToString()`
>
> * Напишите метод, чтобы выводить всю информацию, которая хранится в архиве, на экран после каждого из шагов;
> * можно использовать этот метод после каждого из пунктов ниже, чтобы визуализировать статус архива.

#### Реализация

Для того, чтобы удостовериться, что вы всё реализовали правильно, запустите следующие действия процесса:

* создайте архив;
* создайте 20 объектов `Shell()` и 10 объектов `Emerald()`;
* оцените все созданные объекты и учтите их в архиве, создав соответствующие записи `Entry()`;
* отправьте все изумруды `Emerald()` под спуд, а скорлупки `Shell()` в монетолитейное отделение, обновив существующие записи о них;
* переплавьте все золотые скорлупки `Shell()` в монеты `Coin()`, обновите существующие записи о скорлупках и создайте новые о монетах;
* засекретьте все записи об изумрудах;
* удалите записи о скорлупках;
* рассекретьте часть записей об изумрудах;
* добавьте дополнительную информацию к записям о рассекреченных изумрудах;
* получите информацию о всех монетах в архиве.


## Задача 2
 
Что рекомендуется использовать:

* конструкцию try catch
* инструкцию throw, возвращая правильные сообщения об ошибках;
* классы типа Exception для обозначения уникальных ошибок;
* инструкцию finally для вывода сообщения о результате действия.
* реализовать собственные классы ошибок

### Анекдот 
Заходит одинаковый тестировщик в бар. Заказывает:

кружку лимонада,
2 кружки лимонада,
0 кружек лимонада,
999999999 кружек лимонада,
ящерицу в стакане,
1 кружку лимонада,
qwerty кружек лимонада.
Первый реальный заказ: “Дайте мне, пожалуйста, стакан воды.”

Это задание предлагает вам свободу выбора в решении, и вы можете придумать уникальный способ обработки анекдота. Удачи в программировании! 

## Создание репозитория

* Нажмите на кнопку "Repositories" (Репозитории) в верхнем меню.
* Нажмите на зеленую кнопку "New" (Создать).
* Введите имя репозитория в поле "Repository name" (Название репозитория). 
* Убедитесь, что опция "Public" (Публичный) не выбрана и вместо этого выберите "Private" (Приватный). Но можете и публичный :)
* Выберите опцию "Initialize this repository with a README" (Инициализировать данный репозиторий файлом README). Таким образом, будет создан новый репозиторий с файлом README.
* Нажмите на зеленую кнопку "Create repository" (Создать репозиторий), чтобы завершить.
* Добавьте https://github.com/Zuzokin в коллабораторы, чтобы я мог проверить ваше решение, для этого зайти в настройки репозитория и выбрать вкладку `collaborators`

## Отправка решения
* Каждый раз создавайте новую ветку для каждого домашнего задания, используя следующую конвенцию именования веток: `название-домашнего-задания`.
* Пишите код и выполняйте необходимые изменения в своем репозитории внутри созданной ветки.
* Как только вы закончите работу над домашним заданием, создайте pull request (пулл реквест) для ваших изменений.
* На вашем основном репозитории перейдите на вкладку "Pull Requests" (Пулл реквесты), создайте новый пулл реквест и добавьте соответствующие детали, включая описание изменений и ссылку на пулл реквест.
* Отправь ссылку на пулл реквест для code review, чтобы я мог проверить ваш код и оставить комментарии.


